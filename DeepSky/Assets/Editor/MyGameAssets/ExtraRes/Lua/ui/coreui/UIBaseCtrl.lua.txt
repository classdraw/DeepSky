local Ctrl=Class("UIBaseCtrl")
function Ctrl:ctor()
    self.m_View=nil;
    self.m_ResHandle=nil;
end

function Ctrl:dtor()

end

--构建接口 需要创建view 创建模型以及绑定
function Ctrl:Build(uiData)--这里uiData就是UIConfigData数据
    self.uiData=uiData;
    --1new一个view
    if self.m_View==nil then
        self.m_View=require(self.uiData.path.."View").New();
    end

    --2创建一个模型gameobject
    self.m_ResHandle=GameResourceManager.GetInstance():LoadResourceSync("UI_"..self.uiData.uiName);
    if self.m_ResHandle==nil or self.m_ResHandle:GetObj()==nil then
        XLogger.LogError(self.uiData.uiName.."Ctrl:Build Error!!!");
        return;
    end
    
    --3模型与view层绑定
    self.m_View:Build(self.m_ResHandle:GetGameObject());
    --4module层与view 交互绑定
    if self.m_Module==nil then
        self.m_Module=require(self.uiData.path.."Module").New();
    end
    
    --5todo ctrl控制module和view 的vm绑定 走曹磊那套

end

function Ctrl:GetView()
    return self.m_View;
end

function Ctrl:GetViewObj()
    return self.m_View.m_Obj;
end

function Ctrl:GetUIName()
    return self.uiData.uiName;
end

function Ctrl:OpenWindow(param)
    --数据管道dal绑定丢这里  
    self:OnOpenWindow(param);
    self:_bindDAL();
end

function Ctrl:UpdateWindow(param)
    
    self:OnUpdateWindow(param);
end

function Ctrl:CloseWindow()
    self:_unbindDAL();
    --数据管道dal绑定丢这里  
    self:OnCloseWindow();
end

function Ctrl:Release()
    self:OnRelease();
    --1需要解绑  不置空，因为需要复用
    self.m_Module:Release();
    self.m_View:Release();
    --2资源层卸载
    if self.m_ResHandle~=nil then
        self.m_ResHandle:Dispose();
    end
    self.m_ResHandle=nil;
    --3
end

function Ctrl:_bindDAL()
    if self.ExtraConfig~=nil then

    end
    --绑定好 数据需要提前刷一次
    self:OnDALPush(nil);
end

function Ctrl:_unbindDAL()
    if self.ExtraConfig~=nil then

    end
end



---下面的方法才可以继承
function Ctrl:OnOpenWindow(param)end
function Ctrl:OnUpdateWindow(param)end
function Ctrl:OnCloseWindow()end
function Ctrl:OnRelease()end
function Ctrl:OnDALPush(data)end

return Ctrl;